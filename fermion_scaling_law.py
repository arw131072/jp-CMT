# -*- coding: utf-8 -*-
"""fermion scaling law.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/12gc4LS-Oi19mB4-SdS6Lc0E3oQAddVeI
"""

import numpy as np
import matplotlib.pyplot as plt
import scipy.linalg as la

L = 300 # total chain length
t = 1   # hopping energy

# consider the half-filled substate (length M = L/2)
half_filled = L // 2

# 1D tight-binding chain
# nearest-neighbour hopping & uniform amplitude
H = np.zeros((L,L), dtype=np.float64)
for i in range(L):
    H[i, (i + 1) % L] = -t
    H[i, (i - 1) % L] = -t
print('hopping hamiltonial is = ', H)

# diagonalize hopping hamiltonian
evals, evecs = la.eigh(H)
print('evals = ', evals, 'dimensions = ', evals.shape)
print('evecs = ', evecs, 'dimensions = ', evecs.shape)
# evecs & evals of single-particle states

# occupies the lowest half-filling states (eigen energies sorted acsendingly)
occu_indices = np.argsort(evals)[:half_filled]
print('occupied indices = ', occu_indices)
# corresponding eigenvectors (occupied single-particle states)
occu_psi = evecs[:, occu_indices]
print('occupied eigenvectors = ', occu_psi, 'dimensions = ', occu_psi.shape)

# correlation matrix for the full system: C_ij = <c_i† c_j>
C_full = occu_psi @ occu_psi.conj().T

# entanglement entropy of the subsystem from corr. matrix
# takes corr. matrix of subsystem, returns scalar
def entanglement_entropy(c_sub):

  # diagonalize corr. matrix to get eigenvalues ζ_k
  # la.eigvalsh is for Hermitian (or real symmetric) matrices
  zeta = la.eigvalsh(c_sub)

  # prevent numerical instability when ζ_k is very close to 0 or 1
  zeta = np.clip(zeta, 1e-12, 1 - 1e-12)

  # S = -Σ_k [ζ_k log ζ_k + (1 - ζ_k) log(1 - ζ_k)]
  # von Neumann entropy of a free fermionic Gaussian state
  entropy = -np.sum(zeta * np.log(zeta) + (1 - zeta) * np.log(1 - zeta))

  return entropy

# debugging: test H' = ln[(1-C)/C] for specific subsystem size
# this is the (transpose) of the subsystem entanglement hamiltonian
M_test = 20 # extract 20 sites
C_sub_test = C_full[:M_test, :M_test] # top-left 20*20 block

# compute H_sub = ln((1-C)/C)
S_identity = np.eye(M_test)
H_sub = la.logm((S_identity - C_sub_test) @ la.inv(C_sub_test))

print('H_sub = ', H_sub, 'dimensions = ', H_sub.shape)

# eigenvalues of C and H' from preschel paper
zeta_test = la.eigvalsh(C_sub_test)
eps_test = la.eigvalsh(H_sub)
zeta_from_eps = 1.0 / (np.exp(eps_test) + 1.0)
# print
print('zeta_test = ', zeta_test, 'dimensions = ', zeta_test.shape)
print('eps_test = ', eps_test, 'dimensions = ', eps_test.shape)
print('zeta_from_eps = ', zeta_from_eps, 'dimensions = ', zeta_from_eps.shape)

# entanglement entropy scaling law
max_LA = 20 # max allowed subsystem length adjust as needed
sizes = np.arange(1, max_LA + 1) # sizes of the LA subsystem we analyze
entropies = np.array([entanglement_entropy(C_full[:m, :m]) for m in sizes]) # upper-left block

# plot S vs log(L)
plt.figure()
plt.plot(np.log(sizes), entropies, marker='o')
plt.xlabel(r'$\log L_A$')
plt.ylabel(r'$S_A$')
plt.title('entanglement entropy scaling with subsystem length in 1D free fermion chain')

plt.grid(True)
plt.show()

